# Supabase Architecture SSOT ("Max Features" Model)

This document is the Single Source of Truth for how Supabase is governed and utilized across the Insightpulse AI ecosystem.

## Core Principle

**Everything is DB-first + policy-driven**. Every non-DB feature is an extension of Postgres:

- **Compute**: Edge Functions
- **Events**: Realtime (publication slots)
- **Objects**: Storage buckets
- **Embeddings/Search**: pgvector
- **Automation**: Queues & cron

---

## 1. Database Foundation & Automation

We treat dashboard edits as drift. **All schema changes MUST happen via migrations.**

### Extensions in use (see `0001_extensions.sql`)

- `pgcrypto`, `citext`, `uuid-ossp`: Primitives
- `pg_stat_statements`: Telemetry
- `vector`: AI/Embeddings
- `pg_graphql`, `pg_net`: API layers & webhooks

### The Async Queue Pattern

For integrations (especially Odoo), we use an asynchronous `sync_queue` table:

1. Odoo sends a tight, fast webhook to our `odoo-webhook-ingest` Edge Function.
2. The function blindly inserts the payload into `sync_queue` with an idempotency key.
3. A background worker (or Edge cron) processes the queue line-by-line, updating the DB.

---

## 2. Security & RBAC (Role-Based Access Control)

### The Setup

We employ a custom RBAC model that bridges `auth.users` with domain logic:

1. `public.roles` defines roles (e.g., `admin`, `manager`, `agent`, `member`).
2. `public.user_roles` acts as the join table.
3. `public.profiles` stores metadata (names, avatars).

### Enforcing Policies (RLS)

The `public.has_role('role_name')` helper is used in all RLS policies.
**Every table in the database MUST have Row Level Security (RLS) enabled.**

Example:

```sql
create policy "Admins only" on public.some_table
for all using (public.has_role('admin'));
```

---

## 3. Vector & Knowledge Base (GraphRAG)

Our AI agents rely on a highly-structured, embedding-ready Knowledge Base right inside Postgres.

### Tables

- `kb_chunks`: Stores the raw text, path to the original documentation file, and JSON metadata.
- `kb_embeddings`: Stores the `vector(1536)` embedding generated by OpenAI `text-embedding-3-small`.

### Workflow

1. A markdown file or documentation block is scraped or uploaded.
2. It is split into chunks and inserted into `kb_chunks`.
3. The `embed-chunk-worker` Edge Function picks up the chunk, calls OpenAI, and inserts the result into `kb_embeddings`.
4. Agents utilize the `ivfflat` index for blazing-fast cosine similarity searches.

---

## 4. Edge Functions as the Universal Adapter

If logic shouldn't live in a Postgres trigger, it lives in a Deno Edge Function.

- **`odoo-webhook-ingest`**: Handles high-throughput inbound pulses from the Odoo instance.
- **`embed-chunk-worker`**: Outbound calls to AI providers to generate vectors.
- _(Future)_ **`auth-hook-provision`**: Auto-assigning default roles when a user signs up.

---

## 5. Operations & Drift Control

### CI/CD Enforcement

- **Drift Gate**: GitHub Actions runs `supabase db diff --use-migra` on every pull request. If the production database has drifted from the migrations in the repository, the build fails.
- **Function Tests**: Every Edge Function is booted dynamically in CI to ensure syntax and imports are valid.

### Deployment Strategy

1. Wait for CI gates to pass.
2. `supabase db push` to push cumulative migrations.
3. `supabase functions deploy [name]` to deploy updated compute logic.
