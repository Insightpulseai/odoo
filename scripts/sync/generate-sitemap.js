#!/usr/bin/env node
/**
 * Generate SITEMAP.md
 * Creates a navigable sitemap of documentation
 */

const fs = require('fs');
const path = require('path');
const glob = require('glob');

const ROOT_DIR = path.join(__dirname, '../..');
const OUTPUT_FILE = path.join(ROOT_DIR, 'SITEMAP.md');

// Directories to include in sitemap
const SITEMAP_DIRS = [
  'docs',
  'spec',
  'apps/*/README.md',
  'packages/*/README.md'
];

// Extract title from markdown
function extractTitle(content) {
  const match = content.match(/^#\s+(.+)/m);
  return match ? match[1].trim() : null;
}

// Extract description from markdown
function extractDescription(content) {
  // Look for first paragraph after title
  const lines = content.split('\n');
  let foundTitle = false;

  for (const line of lines) {
    if (line.startsWith('# ')) {
      foundTitle = true;
      continue;
    }
    if (foundTitle && line.trim() && !line.startsWith('#') && !line.startsWith('>') && !line.startsWith('-')) {
      return line.trim().slice(0, 100);
    }
  }

  return null;
}

// Parse frontmatter
function parseFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return {};

  const frontmatter = {};
  const lines = match[1].split('\n');

  for (const line of lines) {
    const [key, ...valueParts] = line.split(':');
    if (key && valueParts.length > 0) {
      frontmatter[key.trim()] = valueParts.join(':').trim().replace(/^["']|["']$/g, '');
    }
  }

  return frontmatter;
}

// Process a documentation file
function processDocFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const frontmatter = parseFrontmatter(content);
    const relativePath = path.relative(ROOT_DIR, filePath);

    return {
      path: relativePath,
      title: frontmatter.title || extractTitle(content) || path.basename(filePath, '.md'),
      description: frontmatter.description || extractDescription(content),
      category: getCategory(relativePath),
      order: frontmatter.order ? parseInt(frontmatter.order) : 999,
      tags: frontmatter.tags ? frontmatter.tags.split(',').map(t => t.trim()) : []
    };
  } catch (error) {
    return null;
  }
}

// Get category from path
function getCategory(filePath) {
  const parts = filePath.split('/');

  if (parts[0] === 'docs') {
    return parts[1] || 'General';
  }
  if (parts[0] === 'spec') {
    return 'Specifications';
  }
  if (parts[0] === 'apps') {
    return `Apps/${parts[1]}`;
  }
  if (parts[0] === 'packages') {
    return `Packages/${parts[1]}`;
  }

  return 'Other';
}

// Group docs by category
function groupByCategory(docs) {
  const groups = {};

  for (const doc of docs) {
    const category = doc.category;
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(doc);
  }

  // Sort within each category
  for (const category of Object.keys(groups)) {
    groups[category].sort((a, b) => {
      if (a.order !== b.order) return a.order - b.order;
      return a.title.localeCompare(b.title);
    });
  }

  return groups;
}

// Generate table of contents
function generateTOC(groups) {
  const lines = [];

  for (const category of Object.keys(groups).sort()) {
    const anchor = category.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    lines.push(`- [${category}](#${anchor})`);
  }

  return lines.join('\n');
}

// Generate markdown
function generateMarkdown(docs) {
  const groups = groupByCategory(docs);
  const lines = [];

  lines.push('# Documentation Sitemap');
  lines.push('');
  lines.push('> Auto-generated by `scripts/sync/generate-sitemap.js`');
  lines.push(`> Last updated: ${new Date().toISOString()}`);
  lines.push('');

  // Stats
  lines.push(`**${docs.length} documents across ${Object.keys(groups).length} categories**`);
  lines.push('');

  // Table of contents
  lines.push('## Table of Contents');
  lines.push('');
  lines.push(generateTOC(groups));
  lines.push('');

  // Each category
  for (const category of Object.keys(groups).sort()) {
    const categoryDocs = groups[category];

    lines.push(`## ${category}`);
    lines.push('');

    // Table format
    lines.push('| Document | Description |');
    lines.push('|----------|-------------|');

    for (const doc of categoryDocs) {
      const link = `[${doc.title}](${doc.path})`;
      const desc = doc.description || '-';
      lines.push(`| ${link} | ${desc} |`);
    }

    lines.push('');
  }

  // Tag index
  const tagIndex = buildTagIndex(docs);
  if (Object.keys(tagIndex).length > 0) {
    lines.push('## Tag Index');
    lines.push('');

    for (const tag of Object.keys(tagIndex).sort()) {
      const tagDocs = tagIndex[tag];
      lines.push(`### ${tag}`);
      lines.push('');
      for (const doc of tagDocs) {
        lines.push(`- [${doc.title}](${doc.path})`);
      }
      lines.push('');
    }
  }

  // Quick links
  lines.push('## Quick Links');
  lines.push('');
  lines.push('- [README](README.md) - Project overview');
  lines.push('- [CLAUDE.md](CLAUDE.md) - AI agent instructions');
  lines.push('- [TREE.md](TREE.md) - Repository structure');
  lines.push('');

  return lines.join('\n');
}

// Build tag index
function buildTagIndex(docs) {
  const index = {};

  for (const doc of docs) {
    for (const tag of doc.tags) {
      if (!index[tag]) {
        index[tag] = [];
      }
      index[tag].push(doc);
    }
  }

  return index;
}

// Main function
async function main() {
  console.log('Generating SITEMAP.md...');

  // Find all documentation files
  const files = [];

  for (const pattern of SITEMAP_DIRS) {
    const matches = glob.sync(path.join(ROOT_DIR, pattern));
    files.push(...matches);
  }

  // Also find all markdown in docs
  const docFiles = glob.sync(path.join(ROOT_DIR, 'docs/**/*.md'));
  files.push(...docFiles);

  // Deduplicate
  const uniqueFiles = [...new Set(files)];

  console.log(`Found ${uniqueFiles.length} documentation files`);

  // Process all files
  const docs = [];
  for (const file of uniqueFiles) {
    const doc = processDocFile(file);
    if (doc) {
      docs.push(doc);
    }
  }

  console.log(`Processed ${docs.length} valid documents`);

  // Generate markdown
  const markdown = generateMarkdown(docs);
  fs.writeFileSync(OUTPUT_FILE, markdown);

  console.log(`Output: ${OUTPUT_FILE}`);
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { generateMarkdown, processDocFile };
