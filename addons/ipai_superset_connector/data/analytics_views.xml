<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- 
        Pre-built Analytics Views for Superset
        These create optimized SQL views for common BI scenarios
        -->

        <!-- SALES ANALYTICS -->
        <record id="analytics_view_sales_orders" model="superset.analytics.view">
            <field name="name">Sales Order Analysis</field>
            <field name="technical_name">superset_sales_order_analysis</field>
            <field name="category">sales</field>
            <field name="sequence">10</field>
            <field name="description">Comprehensive sales order metrics with customer and product dimensions. Aggregates order lines for summary reporting.</field>
            <field name="required_modules">sale</field>
            <field name="sql_definition">
SELECT
    so.id AS order_id,
    so.name AS order_ref,
    so.date_order,
    so.state AS order_state,
    so.amount_total,
    so.amount_untaxed,
    so.amount_tax,
    so.partner_id AS customer_id,
    rp.name AS customer_name,
    rp.city AS customer_city,
    COUNT(sol.id) AS line_count,
    SUM(sol.product_uom_qty) AS total_qty,
    DATE_TRUNC('month', so.date_order) AS order_month,
    DATE_TRUNC('quarter', so.date_order) AS order_quarter,
    so.company_id,
    rcomp.name AS company_name,
    so.create_date,
    so.write_date
FROM sale_order so
LEFT JOIN res_partner rp ON so.partner_id = rp.id
LEFT JOIN res_company rcomp ON so.company_id = rcomp.id
LEFT JOIN sale_order_line sol ON sol.order_id = so.id
WHERE so.state NOT IN ('draft', 'cancel')
GROUP BY 
    so.id, so.name, so.date_order, so.state,
    so.amount_total, so.amount_untaxed, so.amount_tax,
    so.partner_id, rp.name, rp.city,
    so.company_id, rcomp.name,
    so.create_date, so.write_date
            </field>
        </record>

        <!-- FINANCE ANALYTICS -->
        <record id="analytics_view_journal_entries" model="superset.analytics.view">
            <field name="name">Journal Entry Analysis</field>
            <field name="technical_name">superset_account_move_analysis</field>
            <field name="category">finance</field>
            <field name="sequence">20</field>
            <field name="description">Account moves (invoices, bills, journal entries) with partner and journal dimensions.</field>
            <field name="required_modules">account</field>
            <field name="sql_definition">
SELECT
    am.id AS move_id,
    am.name AS move_ref,
    am.date AS accounting_date,
    am.invoice_date,
    am.move_type,
    am.state,
    am.payment_state,
    am.amount_total,
    am.amount_untaxed,
    am.amount_tax,
    am.amount_residual,
    am.partner_id,
    rp.name AS partner_name,
    CASE 
        WHEN am.move_type IN ('out_invoice', 'out_refund', 'out_receipt') THEN 'Customer'
        WHEN am.move_type IN ('in_invoice', 'in_refund', 'in_receipt') THEN 'Vendor'
        ELSE 'Other'
    END AS partner_type,
    am.journal_id,
    aj.name AS journal_name,
    aj.type AS journal_type,
    DATE_TRUNC('month', am.date) AS accounting_month,
    DATE_TRUNC('quarter', am.date) AS accounting_quarter,
    am.company_id,
    rcomp.name AS company_name,
    am.create_date,
    am.write_date
FROM account_move am
LEFT JOIN res_partner rp ON am.partner_id = rp.id
LEFT JOIN account_journal aj ON am.journal_id = aj.id
LEFT JOIN res_company rcomp ON am.company_id = rcomp.id
WHERE am.state = 'posted'
            </field>
        </record>

        <record id="analytics_view_trial_balance" model="superset.analytics.view">
            <field name="name">Trial Balance</field>
            <field name="technical_name">superset_trial_balance</field>
            <field name="category">finance</field>
            <field name="sequence">25</field>
            <field name="description">Account balances aggregated by account for trial balance reporting.</field>
            <field name="required_modules">account</field>
            <field name="sql_definition">
SELECT
    aa.id AS account_id,
    aa.code AS account_code,
    aa.name AS account_name,
    aa.account_type,
    SUM(aml.debit) AS total_debit,
    SUM(aml.credit) AS total_credit,
    SUM(aml.balance) AS balance,
    DATE_TRUNC('month', aml.date) AS period_month,
    aa.company_id,
    rcomp.name AS company_name
FROM account_move_line aml
JOIN account_account aa ON aml.account_id = aa.id
JOIN account_move am ON aml.move_id = am.id
JOIN res_company rcomp ON aa.company_id = rcomp.id
WHERE am.state = 'posted'
GROUP BY 
    aa.id, aa.code, aa.name, aa.account_type,
    DATE_TRUNC('month', aml.date),
    aa.company_id, rcomp.name
            </field>
        </record>

        <!-- BIR TAX COMPLIANCE -->
        <record id="analytics_view_bir_vat" model="superset.analytics.view">
            <field name="name">BIR VAT Analysis (2550Q)</field>
            <field name="technical_name">superset_bir_vat_analysis</field>
            <field name="category">bir</field>
            <field name="sequence">30</field>
            <field name="description">VAT input/output analysis for BIR 2550Q quarterly filing.</field>
            <field name="required_modules">account</field>
            <field name="sql_definition">
SELECT
    am.id AS move_id,
    am.name AS document_ref,
    am.date AS transaction_date,
    rp.name AS party_name,
    rp.vat AS party_tin,
    CASE 
        WHEN am.move_type IN ('out_invoice', 'out_refund') THEN 'Output VAT'
        WHEN am.move_type IN ('in_invoice', 'in_refund') THEN 'Input VAT'
    END AS vat_type,
    am.amount_untaxed AS vatable_amount,
    am.amount_tax AS vat_amount,
    am.amount_total AS total_amount,
    CASE 
        WHEN am.amount_untaxed > 0 
        THEN ROUND((am.amount_tax / am.amount_untaxed * 100)::numeric, 2)
        ELSE 0 
    END AS vat_rate,
    DATE_TRUNC('month', am.date) AS vat_month,
    DATE_TRUNC('quarter', am.date) AS vat_quarter,
    am.company_id
FROM account_move am
LEFT JOIN res_partner rp ON am.partner_id = rp.id
WHERE am.state = 'posted'
  AND am.move_type IN ('out_invoice', 'out_refund', 'in_invoice', 'in_refund')
  AND am.amount_tax != 0
            </field>
        </record>

        <!-- INVENTORY ANALYTICS -->
        <record id="analytics_view_stock_valuation" model="superset.analytics.view">
            <field name="name">Stock Valuation Analysis</field>
            <field name="technical_name">superset_stock_valuation</field>
            <field name="category">inventory</field>
            <field name="sequence">40</field>
            <field name="description">Current stock levels with valuation by location and product.</field>
            <field name="required_modules">stock</field>
            <field name="sql_definition">
SELECT
    sq.id AS quant_id,
    sq.quantity,
    sq.reserved_quantity,
    sq.quantity - sq.reserved_quantity AS available_qty,
    sq.product_id,
    pt.name AS product_name,
    pp.default_code AS sku,
    pc.name AS product_category,
    COALESCE(pt.standard_price, 0) AS unit_cost,
    sq.quantity * COALESCE(pt.standard_price, 0) AS total_value,
    sq.location_id,
    sl.name AS location_name,
    sl.usage AS location_type,
    sq.company_id
FROM stock_quant sq
JOIN product_product pp ON sq.product_id = pp.id
JOIN product_template pt ON pp.product_tmpl_id = pt.id
LEFT JOIN product_category pc ON pt.categ_id = pc.id
JOIN stock_location sl ON sq.location_id = sl.id
WHERE sl.usage = 'internal'
  AND sq.quantity > 0
            </field>
        </record>

        <!-- PROJECT ANALYTICS -->
        <record id="analytics_view_project_tasks" model="superset.analytics.view">
            <field name="name">Project Task Analysis</field>
            <field name="technical_name">superset_project_task_analysis</field>
            <field name="category">project</field>
            <field name="sequence">50</field>
            <field name="description">Project tasks with time tracking and status metrics.</field>
            <field name="required_modules">project</field>
            <field name="sql_definition">
SELECT
    pt.id AS task_id,
    pt.name AS task_name,
    pt.date_deadline,
    pt.priority,
    pts.name AS stage_name,
    pts.fold AS is_completed,
    pt.project_id,
    pp.name AS project_name,
    pt.planned_hours,
    pt.progress,
    CASE 
        WHEN pts.fold = true THEN 'Completed'
        WHEN pt.date_deadline &lt; CURRENT_DATE THEN 'Overdue'
        WHEN pt.date_deadline = CURRENT_DATE THEN 'Due Today'
        ELSE 'On Track'
    END AS status,
    pt.company_id
FROM project_task pt
JOIN project_project pp ON pt.project_id = pp.id
LEFT JOIN project_task_type pts ON pt.stage_id = pts.id
WHERE pt.active = true
            </field>
        </record>

        <!-- HR ANALYTICS -->
        <record id="analytics_view_employees" model="superset.analytics.view">
            <field name="name">Employee Analysis</field>
            <field name="technical_name">superset_employee_analysis</field>
            <field name="category">hr</field>
            <field name="sequence">60</field>
            <field name="description">Employee demographics and organizational structure.</field>
            <field name="required_modules">hr</field>
            <field name="sql_definition">
SELECT
    he.id AS employee_id,
    he.name AS employee_name,
    he.work_email,
    he.job_title,
    hd.name AS department_name,
    hem.name AS manager_name,
    hj.name AS job_position,
    he.active,
    he.company_id
FROM hr_employee he
LEFT JOIN hr_department hd ON he.department_id = hd.id
LEFT JOIN hr_employee hem ON he.parent_id = hem.id
LEFT JOIN hr_job hj ON he.job_id = hj.id
WHERE he.active = true
            </field>
        </record>

    </data>
</odoo>
