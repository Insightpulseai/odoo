#!/usr/bin/env bash
# =============================================================================
# DNS Artifacts Generator ‚Äî SSOT Enforcement
# =============================================================================
# Generates Terraform variables and runtime JSON from subdomain-registry.yaml
#
# Usage:
#   ./scripts/generate-dns-artifacts.sh
#
# Outputs:
#   1. infra/cloudflare/envs/prod/subdomains.auto.tfvars (Terraform input)
#   2. docs/architecture/runtime_identifiers.json (Runtime reference)
#   3. infra/dns/dns-validation-spec.json (CI validation spec)
#
# CI Integration:
#   .github/workflows/dns-sync-check.yml runs this on push to infra/dns/
#   and fails if generated files differ from committed files
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

SSOT_FILE="$REPO_ROOT/infra/dns/subdomain-registry.yaml"
TF_OUTPUT="$REPO_ROOT/infra/cloudflare/envs/prod/subdomains.auto.tfvars"
JSON_OUTPUT="$REPO_ROOT/docs/architecture/runtime_identifiers.json"
VALIDATION_OUTPUT="$REPO_ROOT/infra/dns/dns-validation-spec.json"

# Ensure yq is installed
if ! command -v yq &> /dev/null; then
    echo "‚ùå Error: yq is required but not installed."
    echo "Install with: brew install yq (macOS) or see https://github.com/mikefarah/yq"
    exit 1
fi

# Ensure jq is installed
if ! command -v jq &> /dev/null; then
    echo "‚ùå Error: jq is required but not installed."
    echo "Install with: brew install jq (macOS)"
    exit 1
fi

echo "üîÑ Generating DNS artifacts from SSOT..."
echo "   Source: $SSOT_FILE"

# =============================================================================
# 1. Generate Terraform Variables (subdomains.auto.tfvars)
# =============================================================================
echo "üìù Generating Terraform variables..."

cat > "$TF_OUTPUT" << 'EOF'
# =============================================================================
# Terraform Auto-Generated Variables ‚Äî DO NOT EDIT BY HAND
# =============================================================================
# Generated by: scripts/generate-dns-artifacts.sh
# Source: infra/dns/subdomain-registry.yaml
# Last generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
#
# This file is automatically generated from the subdomain registry SSOT.
# Manual edits will be overwritten. Edit subdomain-registry.yaml instead.
# =============================================================================

EOF

# Extract A record subdomains
A_SUBDOMAINS=$(yq eval '.subdomains[] | select(.type == "A") | .name' "$SSOT_FILE" | \
    awk '{printf "\"%s\",\n", $0}' | sed '$ s/,$//')

cat >> "$TF_OUTPUT" << EOF
# Core subdomains (A records pointing to origin_ip)
app_subdomains = [
$A_SUBDOMAINS
]

# Additional A record subdomains (e.g., www)
extra_a_subdomains = []

EOF

echo "‚úÖ Generated: $TF_OUTPUT"

# =============================================================================
# 2. Generate Runtime Identifiers JSON
# =============================================================================
echo "üìù Generating runtime identifiers JSON..."

DOMAIN=$(yq eval '.domain' "$SSOT_FILE")
CONSOLIDATION_DATE=$(yq eval '.environment' "$SSOT_FILE")

# Start JSON structure
cat > "$JSON_OUTPUT" << EOF
{
  "domain": "$DOMAIN",
  "consolidation_date": "$(date -u +"%Y-%m-%d")",
  "generated_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "generator": "scripts/generate-dns-artifacts.sh",
  "source": "infra/dns/subdomain-registry.yaml",
  "nameservers": [],
  "services": {
EOF

# Process each active subdomain
FIRST=true
yq eval '.subdomains[] | select(.status == "active" or .status == "pending_verification")' "$SSOT_FILE" -o=json | \
jq -c '.' | while IFS= read -r subdomain; do
    if [ "$FIRST" = false ]; then
        echo "," >> "$JSON_OUTPUT"
    fi
    FIRST=false

    NAME=$(echo "$subdomain" | jq -r '.name')
    TYPE=$(echo "$subdomain" | jq -r '.type')
    SERVICE=$(echo "$subdomain" | jq -r '.service')
    STATUS=$(echo "$subdomain" | jq -r '.status // "active"')
    OWNER=$(echo "$subdomain" | jq -r '.owner_system // "Unknown"')
    HEALTH=$(echo "$subdomain" | jq -r '.health_check // ""')
    TLS=$(echo "$subdomain" | jq -r '.tls_mode // "Full (strict)"')
    PROXIED=$(echo "$subdomain" | jq -r '.cloudflare_proxied // false')

    if [ "$TYPE" = "A" ]; then
        TARGET=$(yq eval '.origin_ip' "$SSOT_FILE")
        PORT=$(echo "$subdomain" | jq -r '.port // null')
        RUNTIME_HOST="odoo-production"
    else
        TARGET=$(echo "$subdomain" | jq -r '.target')
        PORT="null"
        RUNTIME_HOST="DO App Platform"
    fi

    cat >> "$JSON_OUTPUT" << SUBDOMAIN
    "$NAME": {
      "fqdn": "$NAME.$DOMAIN",
      "record_type": "$TYPE",
      "target": "$TARGET",
      "cloudflare_proxied": $PROXIED,
      "origin_port": $PORT,
      "tls_mode": "$TLS",
      "runtime_host": "$RUNTIME_HOST",
      "owner_system": "$OWNER",
      "health_check": "$HEALTH",
      "status": "$STATUS"
    }
SUBDOMAIN
done

# Add deprecated section
cat >> "$JSON_OUTPUT" << 'EOF'
  },
  "deprecated": {
EOF

FIRST=true
yq eval '.deprecated[]' "$SSOT_FILE" -o=json | jq -c '.' | while IFS= read -r deprecated; do
    if [ "$FIRST" = false ]; then
        echo "," >> "$JSON_OUTPUT"
    fi
    FIRST=false

    NAME=$(echo "$deprecated" | jq -r '.name')
    DATE=$(echo "$deprecated" | jq -r '.deprecated_date')
    REASON=$(echo "$deprecated" | jq -r '.reason')

    cat >> "$JSON_OUTPUT" << DEPRECATED
    "$NAME": {
      "fqdn": "$NAME.$DOMAIN",
      "deprecated_date": "$DATE",
      "replacement": null,
      "reason": "$REASON",
      "dns_removed": true,
      "container_removed": true
    }
DEPRECATED
done

cat >> "$JSON_OUTPUT" << 'EOF'
  }
}
EOF

echo "‚úÖ Generated: $JSON_OUTPUT"

# =============================================================================
# 3. Generate Validation Spec (for CI drift detection)
# =============================================================================
echo "üìù Generating validation spec..."

cat > "$VALIDATION_OUTPUT" << EOF
{
  "version": "1.0",
  "generated_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "source": "infra/dns/subdomain-registry.yaml",
  "validation_rules": {
    "terraform_file": "infra/cloudflare/envs/prod/subdomains.auto.tfvars",
    "runtime_file": "docs/architecture/runtime_identifiers.json",
    "expected_subdomain_count": $(yq eval '.subdomains | length' "$SSOT_FILE"),
    "expected_active_count": $(yq eval '[.subdomains[] | select(.status == "active")] | length' "$SSOT_FILE"),
    "expected_deprecated_count": $(yq eval '.deprecated | length' "$SSOT_FILE")
  },
  "checksums": {
    "ssot_file": "$(shasum -a 256 "$SSOT_FILE" | awk '{print $1}')",
    "terraform_file": "$(shasum -a 256 "$TF_OUTPUT" | awk '{print $1}')",
    "runtime_file": "$(shasum -a 256 "$JSON_OUTPUT" | awk '{print $1}')"
  }
}
EOF

echo "‚úÖ Generated: $VALIDATION_OUTPUT"

# =============================================================================
# 4. Generate Cloudflare Email-Auth Records Artifact
#    Reads infra/dns/*.yaml files with purpose: *outbound_auth*
#    and emits apply-ready JSON for scripts/apply_dns_cloudflare.py.
# =============================================================================
echo "üìù Generating Cloudflare email-auth records artifact..."

CF_AUTH_OUTPUT="$REPO_ROOT/artifacts/dns/cloudflare_records.json"
mkdir -p "$(dirname "$CF_AUTH_OUTPUT")"

AUTH_JSON=$(REPO_ROOT="$REPO_ROOT" python3 - <<'PYEOF'
import glob, json, os, sys

repo_root = os.environ.get("REPO_ROOT", ".")
pattern   = os.path.join(repo_root, "infra", "dns", "*.yaml")

auth_records = []
zone = None

for fpath in sorted(glob.glob(pattern)):
    fname = os.path.basename(fpath)
    if fname == "subdomain-registry.yaml":
        continue
    with open(fpath) as f:
        raw = f.read()

    # Lightweight line-by-line parser for our constrained YAML schema
    file_records = []
    lines = raw.splitlines()
    doc_meta = {}
    current_record = None
    records_section = False

    for line in lines:
        stripped = line.strip()
        if stripped.startswith("#") or not stripped:
            continue
        if stripped.startswith("- type:"):
            current_record = {"type": stripped.split(":", 1)[1].strip()}
            records_section = True
        elif records_section and current_record is not None and ":" in stripped and not stripped.startswith("-"):
            k, _, v = stripped.partition(":")
            k = k.strip()
            v = v.strip().strip('"')
            if k == "ttl":
                current_record[k] = int(v)
                file_records.append(dict(current_record))
                current_record = None
            else:
                current_record[k] = v
        elif ":" in stripped and not stripped.startswith("-"):
            k, _, v = stripped.partition(":")
            k = k.strip()
            v = v.strip().strip('"')
            if k != "records":
                doc_meta[k] = v

    purpose   = doc_meta.get("purpose", "")
    file_zone = doc_meta.get("zone", "")

    if "outbound_auth" not in purpose:
        continue

    auth_records.extend(file_records)
    if zone is None and file_zone:
        zone = file_zone

output = {
    "zone":      zone or "insightpulseai.com",
    "generated": True,
    "source":    "infra/dns/*_auth files via generate-dns-artifacts.sh",
    "records": [
        {
            "type":    r.get("type", ""),
            "name":    r.get("name", ""),
            "content": r.get("value", r.get("content", "")),
            "ttl":     r.get("ttl", 3600),
        }
        for r in auth_records
        if r.get("type") and r.get("name") and (r.get("value") or r.get("content"))
    ],
}
print(json.dumps(output, indent=2))
PYEOF
)

if [ -n "$AUTH_JSON" ]; then
    echo "$AUTH_JSON" > "$CF_AUTH_OUTPUT"
    RECORD_COUNT=$(echo "$AUTH_JSON" | python3 -c "import json,sys; print(len(json.load(sys.stdin)['records']))" 2>/dev/null || echo "?")
    echo "‚úÖ Generated: $CF_AUTH_OUTPUT ($RECORD_COUNT record(s))"
else
    echo "‚ö†Ô∏è  No auth companion YAML files found ‚Äî $CF_AUTH_OUTPUT not written"
fi

# =============================================================================
# Summary
# =============================================================================
echo ""
echo "‚úÖ DNS artifacts generated successfully!"
echo ""
echo "Generated files:"
echo "  1. $TF_OUTPUT"
echo "  2. $JSON_OUTPUT"
echo "  3. $VALIDATION_OUTPUT"
[ -f "$CF_AUTH_OUTPUT" ] && echo "  4. $CF_AUTH_OUTPUT"
echo ""
echo "Next steps:"
echo "  1. Review generated files"
echo "  2. git add infra/dns/ infra/cloudflare/ docs/architecture/ artifacts/dns/"
echo "  3. git commit -m 'chore(infra): update DNS SSOT'"
echo "  4. git push (CI will validate sync)"
echo ""
echo "To publish email auth records to Cloudflare + verify Mailgun:"
echo "  CF_API_TOKEN=\$CF_API_TOKEN python3 scripts/apply_dns_cloudflare.py"
echo "  MAILGUN_API_KEY=\$MAILGUN_API_KEY python3 scripts/verify_mailgun_domain.py"
echo ""
