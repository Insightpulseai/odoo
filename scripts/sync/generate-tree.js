#!/usr/bin/env node
/**
 * Generate TREE.md
 * Creates a tree view of the repository structure
 */

const fs = require('fs');
const path = require('path');

const ROOT_DIR = path.join(__dirname, '../..');
const OUTPUT_FILE = path.join(ROOT_DIR, 'TREE.md');

// Patterns to exclude
const EXCLUDE_PATTERNS = [
  'node_modules',
  '.git',
  '.next',
  '__pycache__',
  '.pytest_cache',
  '.venv',
  'venv',
  'dist',
  'build',
  '.turbo',
  'coverage',
  '.nyc_output',
  '*.log',
  '*.pyc',
  '.DS_Store',
  'Thumbs.db'
];

// Max depth for tree generation
const MAX_DEPTH = 4;

// Directory icons
const ICONS = {
  default: '',
  apps: '',
  packages: '',
  spec: '',
  docs: '',
  scripts: '',
  supabase: '',
  workflows: '',
  addons: '',
  infra: '☁️',
  '.github': '',
  '.claude': ''
};

// Check if path should be excluded
function shouldExclude(name) {
  for (const pattern of EXCLUDE_PATTERNS) {
    if (pattern.startsWith('*')) {
      if (name.endsWith(pattern.slice(1))) return true;
    } else if (name === pattern) {
      return true;
    }
  }
  return false;
}

// Get directory icon
function getIcon(name, isDir) {
  if (!isDir) return '';
  return ICONS[name] || '';
}

// Generate tree structure
function generateTree(dir, prefix = '', depth = 0) {
  if (depth >= MAX_DEPTH) {
    return [];
  }

  const lines = [];

  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true })
      .filter(e => !shouldExclude(e.name))
      .sort((a, b) => {
        // Directories first
        if (a.isDirectory() && !b.isDirectory()) return -1;
        if (!a.isDirectory() && b.isDirectory()) return 1;
        return a.name.localeCompare(b.name);
      });

    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const isLast = i === entries.length - 1;
      const connector = isLast ? '└── ' : '├── ';
      const newPrefix = prefix + (isLast ? '    ' : '│   ');

      const icon = getIcon(entry.name, entry.isDirectory());
      const iconStr = icon ? `${icon} ` : '';

      if (entry.isDirectory()) {
        lines.push(`${prefix}${connector}${iconStr}${entry.name}/`);

        // Recurse into directory
        const subPath = path.join(dir, entry.name);
        const subLines = generateTree(subPath, newPrefix, depth + 1);

        // Add count comment for deep directories
        if (depth === MAX_DEPTH - 1) {
          const count = countContents(subPath);
          if (count > 0) {
            lines[lines.length - 1] += ` (${count} items)`;
          }
        } else {
          lines.push(...subLines);
        }
      } else {
        lines.push(`${prefix}${connector}${entry.name}`);
      }
    }
  } catch (error) {
    lines.push(`${prefix}[Error: ${error.message}]`);
  }

  return lines;
}

// Count directory contents
function countContents(dir) {
  try {
    return fs.readdirSync(dir).filter(f => !shouldExclude(f)).length;
  } catch {
    return 0;
  }
}

// Get directory stats
function getStats(dir) {
  let files = 0;
  let dirs = 0;

  function walk(currentDir) {
    try {
      const entries = fs.readdirSync(currentDir, { withFileTypes: true });
      for (const entry of entries) {
        if (shouldExclude(entry.name)) continue;

        if (entry.isDirectory()) {
          dirs++;
          walk(path.join(currentDir, entry.name));
        } else {
          files++;
        }
      }
    } catch {
      // Ignore errors
    }
  }

  walk(dir);
  return { files, dirs };
}

// Generate markdown output
function generateMarkdown() {
  const lines = [];

  lines.push('# Repository Structure');
  lines.push('');
  lines.push('> Auto-generated by `scripts/sync/generate-tree.js`');
  lines.push(`> Last updated: ${new Date().toISOString()}`);
  lines.push('');

  // Stats
  const stats = getStats(ROOT_DIR);
  lines.push(`**${stats.dirs} directories, ${stats.files} files**`);
  lines.push('');

  // Legend
  lines.push('## Legend');
  lines.push('');
  lines.push('| Icon | Meaning |');
  lines.push('|------|---------|');
  lines.push('|  | Applications |');
  lines.push('|  | Packages |');
  lines.push('|  | Specifications |');
  lines.push('|  | Documentation |');
  lines.push('|  | Scripts |');
  lines.push('|  | Supabase |');
  lines.push('|  | Workflows |');
  lines.push('|  | Odoo Addons |');
  lines.push('| ☁️ | Infrastructure |');
  lines.push('|  | GitHub |');
  lines.push('|  | Claude Config |');
  lines.push('');

  // Tree
  lines.push('## Structure');
  lines.push('');
  lines.push('```');
  lines.push('./');
  lines.push(...generateTree(ROOT_DIR));
  lines.push('```');
  lines.push('');

  // Key directories
  lines.push('## Key Directories');
  lines.push('');
  lines.push('| Directory | Purpose |');
  lines.push('|-----------|---------|');
  lines.push('| `apps/` | Applications (control-room, web) |');
  lines.push('| `packages/` | Shared packages (agent-core, github-app) |');
  lines.push('| `spec/` | Spec bundles for features |');
  lines.push('| `docs/` | Documentation |');
  lines.push('| `scripts/` | Automation scripts |');
  lines.push('| `supabase/` | Migrations and functions |');
  lines.push('| `workflows/` | n8n workflow definitions |');
  lines.push('| `addons/` | Odoo modules |');
  lines.push('| `infra/` | Infrastructure as code |');
  lines.push('');

  return lines.join('\n');
}

// Main function
async function main() {
  console.log('Generating TREE.md...');

  const markdown = generateMarkdown();
  fs.writeFileSync(OUTPUT_FILE, markdown);

  const stats = getStats(ROOT_DIR);
  console.log(`Generated tree with ${stats.dirs} directories and ${stats.files} files`);
  console.log(`Output: ${OUTPUT_FILE}`);
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

module.exports = { generateTree, generateMarkdown };
