#!/usr/bin/env python3
"""
build_index.py
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Generate docs/catalog/INDEX.md from all *.catalog.json files.
Output is deterministic ‚Äî stable sort by use_case then status then id.

Exit codes:
  0  Index written (or already up-to-date with --check)
  1  Drift detected (only with --check)
  2  Error

Usage:
  python3 scripts/catalog/build_index.py           # write INDEX.md
  python3 scripts/catalog/build_index.py --check   # fail if INDEX.md would change (CI)
"""

import json
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).parent.parent.parent
CATALOG_DIR = REPO_ROOT / "docs" / "catalog"
INDEX_PATH = CATALOG_DIR / "INDEX.md"

CHECK_MODE = "--check" in sys.argv

# Canonical use_case group order ‚Äî determines section order in INDEX.md
# Items appear under FIRST matching group only (deterministic; no item listed twice)
USE_CASE_GROUPS = [
    ("ops-console",   "Ops Console Baselines"),
    ("odoo-runtime",  "Odoo Runtime"),
    ("observability", "Observability"),
    ("platform-kit",  "Supabase Platform Kit / UI"),
    ("ai-ops-agent",  "AI / Agents (AI SDK, MCP, streaming)"),
    ("multi-tenant",  "Multi-tenant / Platforms"),
    ("marketing",     "Marketing Sites"),
]

ADOPTION_ORDER = {"adopt": 0, "harvest": 1, "reference": 2}
RISK_ORDER = {"low": 0, "medium": 1, "high": 2}
ADOPTION_EMOJI = {"adopt": "‚úÖ", "harvest": "üåæ", "reference": "üìñ"}


def load_all_items() -> list[dict]:
    items = []
    for path in sorted(CATALOG_DIR.glob("*.catalog.json")):
        data = json.loads(path.read_text())
        source = data.get("source", {})
        for item in data.get("items", []):
            items.append({**item, "_source_provider": source.get("provider"), "_source_type": source.get("type"), "_catalog_file": path.name})
    return items


def assign_group(item: dict) -> str:
    """Return the first canonical group key that matches item's use_cases, or 'misc'."""
    uc = set(item.get("use_cases", []))
    for key, _ in USE_CASE_GROUPS:
        if key in uc:
            return key
    return "misc"


def render_index(items: list[dict]) -> str:
    lines = [
        "<!-- AUTO-GENERATED by scripts/catalog/build_index.py ‚Äî do not edit directly -->",
        "<!-- Run: python3 scripts/catalog/build_index.py -->",
        "",
        "# Catalog Index",
        "",
        "All Vercel and Supabase examples, templates, and UI resources tracked in this monorepo.",
        "",
        "**Legend**: ‚úÖ adopt | üåæ harvest | üìñ reference | üü¢ approved | üü° candidate | ‚õî deprecated",
        "",
        "---",
        "",
    ]

    # Assign each item to exactly one group (first matching in GROUP_ORDER)
    groups: dict[str, list[dict]] = {key: [] for key, _ in USE_CASE_GROUPS}
    groups["misc"] = []
    for item in items:
        groups[assign_group(item)].append(item)

    for use_case_key, group_title in USE_CASE_GROUPS:
        group_items = groups[use_case_key]
        # Sort: adoption_level (adopt‚Üíharvest‚Üíreference), risk (low‚Üímedium‚Üíhigh), title A‚ÜíZ
        group_items.sort(key=lambda x: (
            ADOPTION_ORDER.get(x.get("adoption_level", "reference"), 9),
            RISK_ORDER.get(x.get("risk", "high"), 9),
            x.get("title", ""),
        ))
        if not group_items:
            continue

        lines.append(f"## {group_title}")
        lines.append("")
        lines.append("| Adoption | Status | Title | Tags | What to lift |")
        lines.append("|----------|--------|-------|------|-------------|")

        for item in group_items:
            adoption_icon = ADOPTION_EMOJI.get(item.get("adoption_level", "reference"), "üìñ")
            status = item.get("status", "candidate")
            status_icon = {"approved": "üü¢", "candidate": "üü°", "deprecated": "‚õî"}.get(status, "üü°")
            title = item.get("title", "")
            url = item.get("url", "")
            tags = ", ".join(f"`{t}`" for t in item.get("tags", [])[:4])
            what = item.get("what_to_lift", [""])
            first_lift = what[0] if what else "‚Äî"
            # Truncate long lift descriptions
            if len(first_lift) > 60:
                first_lift = first_lift[:57] + "..."
            title_link = f"[{title}]({url})" if url else title
            lines.append(f"| {adoption_icon} | {status_icon} {status} | {title_link} | {tags} | {first_lift} |")

        lines.append("")

    # Summary counts
    total = len(items)
    approved = sum(1 for i in items if i.get("status") == "approved")
    candidate = sum(1 for i in items if i.get("status") == "candidate")
    deprecated = sum(1 for i in items if i.get("status") == "deprecated")

    lines.extend([
        "---",
        "",
        f"**Total**: {total} items ({approved} approved, {candidate} candidate, {deprecated} deprecated)",
        "",
        "**Sources**: See `docs/catalog/SOURCES.md`",
        "**Governance**: See `docs/catalog/README.md`",
        "",
    ])

    return "\n".join(lines)


def main() -> int:
    catalog_files = list(CATALOG_DIR.glob("*.catalog.json"))
    if not catalog_files:
        print(f"ERROR: No catalog files found in {CATALOG_DIR}", file=sys.stderr)
        return 2

    items = load_all_items()
    content = render_index(items)

    if CHECK_MODE:
        if INDEX_PATH.exists() and INDEX_PATH.read_text() == content:
            print(f"‚úÖ {INDEX_PATH.relative_to(REPO_ROOT)} is up-to-date.")
            return 0
        print(f"‚ùå {INDEX_PATH.relative_to(REPO_ROOT)} is out of date. Run: python3 scripts/catalog/build_index.py", file=sys.stderr)
        return 1

    INDEX_PATH.write_text(content)
    print(f"‚úÖ Wrote {INDEX_PATH.relative_to(REPO_ROOT)} ({len(items)} items)")
    return 0


if __name__ == "__main__":
    sys.exit(main())
