#!/usr/bin/env python3
"""
Refactor Triage Engine
Auto-creates GitHub issues from refactor findings with intelligent prioritization.
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Any
import yaml

try:
    import requests
except ImportError:
    print("Error: requests not installed. Run: pip install requests", file=sys.stderr)
    sys.exit(1)


class GitHubIssueCreator:
    """GitHub API client for creating refactor issues"""

    def __init__(self, token: str, repo: str):
        self.token = token
        self.repo = repo  # Format: "owner/repo"
        self.api_base = "https://api.github.com"
        self.headers = {
            "Authorization": f"Bearer {token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
        }

    def create_issue(
        self,
        title: str,
        body: str,
        labels: List[str] = None,
        assignees: List[str] = None,
    ) -> Dict[str, Any]:
        """Create a GitHub issue"""
        url = f"{self.api_base}/repos/{self.repo}/issues"

        payload = {
            "title": title,
            "body": body,
            "labels": labels or [],
        }

        if assignees:
            payload["assignees"] = assignees

        response = requests.post(url, headers=self.headers, json=payload)
        response.raise_for_status()

        return response.json()


class RefactorTriage:
    """Intelligent triage and issue creation for refactor findings"""

    def __init__(self, config_path: str = ".refactor/config.yaml"):
        self.config = self._load_config(config_path)

    def _load_config(self, path: str) -> Dict[str, Any]:
        """Load configuration from YAML file"""
        config_file = Path(path)
        if not config_file.exists():
            return {
                "triage": {
                    "auto_issue_threshold": "high",
                    "max_issues_per_pr": 10,
                },
                "github": {
                    "create_issues": True,
                    "add_labels": True,
                },
            }

        with open(config_file) as f:
            return yaml.safe_load(f)

    def should_create_issue(self, finding: Dict[str, Any]) -> bool:
        """Determine if finding should create an issue"""
        threshold = self.config["triage"]["auto_issue_threshold"]
        priority = finding["priority"]

        priority_order = ["low", "medium", "high", "critical"]

        return priority_order.index(priority) >= priority_order.index(threshold)

    def format_issue_title(self, finding: Dict[str, Any]) -> str:
        """Generate issue title from finding"""
        priority_emoji = {
            "critical": "üö®",
            "high": "‚ö†Ô∏è",
            "medium": "üìã",
            "low": "‚ÑπÔ∏è",
        }

        emoji = priority_emoji.get(finding["priority"], "üìã")
        type_name = finding["type"].title()

        return f"{emoji} Refactor: {type_name} in {Path(finding['file']).name}"

    def format_issue_body(self, finding: Dict[str, Any], pr_number: int = None) -> str:
        """Generate issue body from finding"""
        body = f"""## Refactor Opportunity Detected

**Type**: {finding['type'].title()}
**Priority**: {finding['priority'].upper()}
**Score**: {finding.get('score', 'N/A')}

### Location
- **File**: `{finding['file']}`
- **Line**: {finding['line']}
- **Function**: `{finding.get('function', 'N/A')}`

### Issue
{finding['message']}

### Suggested Fix
{finding.get('suggestion', 'See code analysis for details')}

### Metrics
"""

        # Add metrics if available
        if "metrics" in finding:
            for key, value in finding["metrics"].items():
                body += f"- **{key.title()}**: {value}\n"

        # Add PR reference if available
        if pr_number:
            body += f"\n### Related PR\n- #{pr_number}\n"

        body += """
### Acceptance Criteria
- [ ] Refactor applied
- [ ] Tests passing
- [ ] Complexity reduced (if applicable)
- [ ] Evidence generated (before/after metrics)

---
ü§ñ Auto-generated by Refactor Automation
"""

        return body

    def get_labels(self, finding: Dict[str, Any]) -> List[str]:
        """Generate labels for issue"""
        if not self.config["github"]["add_labels"]:
            return []

        labels = ["refactor"]

        # Add priority label
        labels.append(f"priority:{finding['priority']}")

        # Add type label
        labels.append(f"type:{finding['type']}")

        return labels

    def triage_findings(
        self,
        findings_path: str,
        github_token: str = None,
        repo: str = None,
        pr_number: int = None,
        dry_run: bool = False,
    ) -> Dict[str, Any]:
        """Triage findings and create GitHub issues"""

        # Load findings
        with open(findings_path) as f:
            data = json.load(f)

        findings = data.get("findings", [])
        max_issues = self.config["triage"]["max_issues_per_pr"]

        # Filter findings that should create issues
        filtered = [f for f in findings if self.should_create_issue(f)]

        # Limit number of issues
        to_create = filtered[:max_issues]

        print(f"Triage summary:")
        print(f"  Total findings: {len(findings)}")
        print(f"  Eligible for issues: {len(filtered)}")
        print(f"  Will create: {len(to_create)} (max: {max_issues})")

        if dry_run:
            print("\nüîç DRY RUN - Issues that would be created:")
            for finding in to_create:
                title = self.format_issue_title(finding)
                print(f"  - {title}")
            return {"dry_run": True, "would_create": len(to_create)}

        if not github_token or not repo:
            print(
                "\n‚ö†Ô∏è  GitHub token or repo not provided. Skipping issue creation.",
                file=sys.stderr,
            )
            return {"skipped": True, "reason": "Missing credentials"}

        # Create issues
        github = GitHubIssueCreator(github_token, repo)
        created_issues = []

        for finding in to_create:
            try:
                title = self.format_issue_title(finding)
                body = self.format_issue_body(finding, pr_number)
                labels = self.get_labels(finding)

                print(f"\nCreating issue: {title}")

                issue = github.create_issue(
                    title=title,
                    body=body,
                    labels=labels,
                )

                created_issues.append(
                    {
                        "number": issue["number"],
                        "url": issue["html_url"],
                        "title": title,
                    }
                )

                print(f"  ‚úÖ Created: {issue['html_url']}")

            except Exception as e:
                print(f"  ‚ùå Error creating issue: {e}", file=sys.stderr)

        print(f"\n‚úÖ Created {len(created_issues)} issues")

        return {
            "created_count": len(created_issues),
            "issues": created_issues,
        }


def main():
    parser = argparse.ArgumentParser(description="Triage refactor findings and create GitHub issues")
    parser.add_argument(
        "--findings",
        required=True,
        help="Path to findings JSON file",
    )
    parser.add_argument(
        "--config",
        default=".refactor/config.yaml",
        help="Configuration file",
    )
    parser.add_argument(
        "--pr",
        type=int,
        help="PR number (for linking)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be created without creating issues",
    )
    parser.add_argument(
        "--auto-issue",
        action="store_true",
        help="Automatically create issues (requires GITHUB_TOKEN env var)",
    )

    args = parser.parse_args()

    # Initialize triage engine
    triage = RefactorTriage(config_path=args.config)

    # Get GitHub credentials from environment
    github_token = os.getenv("GITHUB_TOKEN")
    github_repo = os.getenv("GITHUB_REPOSITORY", "Insightpulseai/odoo")

    # Run triage
    results = triage.triage_findings(
        findings_path=args.findings,
        github_token=github_token if args.auto_issue else None,
        repo=github_repo,
        pr_number=args.pr,
        dry_run=args.dry_run,
    )

    # Print results
    print("\nTriage complete:")
    print(json.dumps(results, indent=2))


if __name__ == "__main__":
    main()
