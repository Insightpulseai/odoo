#!/usr/bin/env python3
"""
Sync agent instruction files from SSOT.

Reads docs/agent_instructions/SSOT.md and generates tool-specific mirrors:
- CLAUDE.md (for Claude Code)
- AGENTS.md (for Codex CLI + agents.md ecosystem)
- GEMINI.md (for Gemini Code Assist / CLI)

Usage:
    python scripts/agents/sync_agent_instructions.py

Exit codes:
    0: Success
    1: SSOT file not found or read error
    2: Write error
"""

import sys
from pathlib import Path

# Repo root detection
SCRIPT_DIR = Path(__file__).parent.resolve()
REPO_ROOT = SCRIPT_DIR.parent.parent
SSOT_PATH = REPO_ROOT / "docs" / "ai" / "SSOT.md"

# Output paths (relative to repo root)
OUTPUTS: dict[str, Path] = {
    "CLAUDE.md": REPO_ROOT / "CLAUDE.md",
    "AGENTS.md": REPO_ROOT / "AGENTS.md",
    "GEMINI.md": REPO_ROOT / "GEMINI.md",
}

# Tool-specific headers
CLAUDE_HEADER = """# CLAUDE.md — Repo Entry Context (Claude Code)
#
# This file is read automatically by Claude Code at session start.
# It must remain repo-local and deterministic.
#
# Source of Truth:
# - Canonical SSOT lives at: docs/ai/SSOT.md
# - This file is a thin pointer + minimal runtime invariants only.
#
# Update flow:
# - Edit docs/ai/SSOT.md, then run: python scripts/agents/sync_agent_instructions.py
# - CI should fail if this pointer drifts.

## Canonical Pointer
This repo’s authoritative agent instructions are in:
- `docs/ai/SSOT.md`

If you are seeing wrong context in Claude Code, treat that as:
- stale cache OR
- non-canonical file path referenced by CLAUDE.md OR
- missing sync script execution in the branch

---

## Minimal Invariants (keep small)
- Repo: `Insightpulseai/odoo`
- Workspace identifier: `ipai`
- Addons order: `addons/odoo` → `addons/oca` → `addons/ipai`

---

"""

AGENTS_HEADER = """# AGENTS.md — Agent Instructions

> **AUTO-GENERATED from `docs/ai/SSOT.md`**
> This file follows the agents.md convention for Codex CLI and other agent systems.
> DO NOT EDIT THIS FILE DIRECTLY. Edit the SSOT instead, then run:
> `python scripts/agents/sync_agent_instructions.py`

---

"""

GEMINI_HEADER = """# GEMINI.md — Gemini Agent Instructions

> **AUTO-GENERATED from `docs/ai/SSOT.md`**
> This file is for Gemini Code Assist / Gemini CLI integration.
> DO NOT EDIT THIS FILE DIRECTLY. Edit the SSOT instead, then run:
> `python scripts/agents/sync_agent_instructions.py`
>
> **Usage**: Feed this file content into Gemini via wrapper or CLI option.

---

"""

HEADERS = {
    "CLAUDE.md": CLAUDE_HEADER,
    "AGENTS.md": AGENTS_HEADER,
    "GEMINI.md": GEMINI_HEADER,
}


def normalize_text(s: str) -> str:
    """
    Normalize text to stable form across OS/tooling.

    - Convert all line endings to LF (\\n)
    - Ensure single trailing newline
    """
    # Normalize line endings to LF
    s = s.replace("\r\n", "\n").replace("\r", "\n")

    # Ensure single trailing newline
    s = s.rstrip("\n") + "\n"

    return s


def read_ssot() -> str:
    """Read the SSOT file."""
    if not SSOT_PATH.exists():
        print(f"ERROR: SSOT file not found: {SSOT_PATH}", file=sys.stderr)
        sys.exit(1)

    try:
        content = SSOT_PATH.read_text(encoding="utf-8")
        content = normalize_text(content)

        # Validate SSOT is not empty
        if not content.strip():
            print(f"ERROR: SSOT is empty: {SSOT_PATH}", file=sys.stderr)
            sys.exit(1)

        return content
    except Exception as e:
        print(f"ERROR: Failed to read SSOT: {e}", file=sys.stderr)
        sys.exit(1)


def extract_body(ssot_content: str) -> str:
    """
    Extract body content from SSOT, skipping the header.

    We skip the first heading and introductory paragraph, keeping everything
    from the first --- separator onwards.
    """
    lines = ssot_content.splitlines(keepends=True)

    # Find first --- separator
    for i, line in enumerate(lines):
        if line.strip() == "---":
            # Return everything from this separator onwards
            return "".join(lines[i + 1 :])

    # Fallback: return whole content if no separator found
    return ssot_content


def write_output(filename: str, content: str) -> None:
    """Write generated content to output file."""
    output_path = OUTPUTS[filename]
    header = HEADERS[filename]

    try:
        full_content = header + content
        # Normalize before writing to ensure deterministic output
        full_content = normalize_text(full_content)
        output_path.write_text(full_content, encoding="utf-8")
        print(f"✓ Generated: {output_path.relative_to(REPO_ROOT)}")
    except Exception as e:
        print(f"ERROR: Failed to write {filename}: {e}", file=sys.stderr)
        sys.exit(2)


def main() -> None:
    """Main execution."""
    print(f"Reading SSOT from: {SSOT_PATH.relative_to(REPO_ROOT)}")

    ssot_content = read_ssot()
    body = extract_body(ssot_content)

    print("\nGenerating mirrors...")
    for filename in OUTPUTS.keys():
        write_output(filename, body)

    print("\n✅ All agent instruction mirrors synchronized.")
    print("\nNext steps:")
    print("  1. Review generated files (CLAUDE.md, AGENTS.md, GEMINI.md)")
    print("  2. Run drift check: python scripts/agents/check_agent_instruction_drift.py")
    print("  3. Commit all changes if validation passes")


if __name__ == "__main__":
    main()
